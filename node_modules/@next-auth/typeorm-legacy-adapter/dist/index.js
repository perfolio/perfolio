"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypeORMLegacyAdapter = TypeORMLegacyAdapter;
exports.Models = void 0;

var _crypto = require("crypto");

var _require_optional = _interopRequireDefault(require("require_optional"));

var adapterConfig = _interopRequireWildcard(require("./lib/config"));

var _typeorm = require("typeorm");

var _utils = require("./lib/utils");

var _transform = _interopRequireDefault(require("./lib/transform"));

var _models = _interopRequireDefault(require("./models"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const Models = _models.default;
exports.Models = Models;

function TypeORMLegacyAdapter(configOrString, options = {}) {
  const typeOrmConfig = adapterConfig.parseConnectionString(configOrString);
  const {
    models: customModels = {}
  } = options;
  const models = { ..._models.default,
    ...customModels
  };
  (0, _transform.default)(typeOrmConfig, models, options);
  const config = adapterConfig.loadConfig(typeOrmConfig, { ...options,
    models
  });
  const {
    User: {
      model: User
    },
    Account: {
      model: Account
    },
    Session: {
      model: Session
    },
    VerificationRequest: {
      model: VerificationRequest
    }
  } = models;
  let connection = null;
  return {
    async getAdapter({
      session: {
        maxAge,
        updateAge
      },
      secret,
      logger,
      ...appOptions
    }) {
      async function _connect() {
        connection = (0, _typeorm.getConnection)(config.name);

        if (!connection.isConnected) {
          connection = await connection.connect();
        }
      }

      if (!connection) {
        try {
          connection = await (0, _typeorm.createConnection)(config);
        } catch (error) {
          if (error.name === "AlreadyHasActiveConnectionError") {
            await _connect();
          } else {
            logger.error("ADAPTER_CONNECTION_ERROR", error);
            throw error;
          }
        }
      } else {
        await _connect();
      }

      if (process.env.NODE_ENV !== "production") {
        await (0, _utils.updateConnectionEntities)(connection, config.entities);
      }

      const {
        manager
      } = connection;
      let idKey = "id";
      let ObjectId;

      if (config.type === "mongodb") {
        idKey = "_id";
        const mongodb = (0, _require_optional.default)("mongodb");
        ObjectId = mongodb.ObjectId;
      }

      const sessionMaxAge = maxAge * 1000;
      const sessionUpdateAge = updateAge * 1000;

      const hashToken = token => (0, _crypto.createHash)("sha256").update(`${token}${secret}`).digest("hex");

      return {
        displayName: "TYPEORM_LEGACY",

        createUser(profile) {
          return manager.save(new User(profile.name, profile.email, profile.image, profile.emailVerified));
        },

        getUser(id) {
          if (ObjectId && !(id instanceof ObjectId)) {
            id = ObjectId(id);
          }

          return manager.findOne(User, {
            [idKey]: id
          });
        },

        getUserByEmail(email) {
          if (email) {
            return manager.findOne(User, {
              email
            });
          }

          return null;
        },

        async getUserByProviderAccountId(providerId, providerAccountId) {
          const account = await manager.findOne(Account, {
            providerId,
            providerAccountId
          });

          if (account) {
            return await manager.findOne(User, {
              [idKey]: account.userId
            });
          }

          return null;
        },

        updateUser(user) {
          return manager.save(User, user);
        },

        async deleteUser() {},

        linkAccount(userId, providerId, providerType, providerAccountId, refreshToken, accessToken, accessTokenExpires) {
          return manager.save(new Account(userId, providerId, providerType, providerAccountId, refreshToken, accessToken, accessTokenExpires));
        },

        async unlinkAccount() {},

        createSession(user) {
          let expires = null;

          if (sessionMaxAge) {
            const dateExpires = new Date();
            dateExpires.setTime(dateExpires.getTime() + sessionMaxAge);
            expires = dateExpires;
          }

          return manager.save(new Session(user.id, expires));
        },

        async getSession(sessionToken) {
          const session = await manager.findOne(Session, {
            sessionToken
          });

          if (session !== null && session !== void 0 && session.expires && new Date() > new Date(session.expires)) {
            return null;
          }

          return session;
        },

        updateSession(session, force) {
          if (sessionMaxAge && (sessionUpdateAge || sessionUpdateAge === 0) && session.expires) {
            const dateSessionIsDueToBeUpdated = new Date(session.expires);
            dateSessionIsDueToBeUpdated.setTime(dateSessionIsDueToBeUpdated.getTime() - sessionMaxAge);
            dateSessionIsDueToBeUpdated.setTime(dateSessionIsDueToBeUpdated.getTime() + sessionUpdateAge);

            if (new Date() > dateSessionIsDueToBeUpdated) {
              const newExpiryDate = new Date();
              newExpiryDate.setTime(newExpiryDate.getTime() + sessionMaxAge);
              session.expires = newExpiryDate;
            } else if (!force) {
              return null;
            }
          } else {
            if (!force) {
              return null;
            }
          }

          return manager.save(Session, session);
        },

        deleteSession(sessionToken) {
          return manager.delete(Session, {
            sessionToken
          });
        },

        async createVerificationRequest(identifier, url, token, _, provider) {
          const {
            sendVerificationRequest,
            maxAge
          } = provider;
          const hashedToken = hashToken(token);
          let expires = null;

          if (maxAge) {
            const dateExpires = new Date();
            dateExpires.setTime(dateExpires.getTime() + maxAge * 1000);
            expires = dateExpires;
          }

          await manager.save(new VerificationRequest(identifier, hashedToken, expires));
          await sendVerificationRequest({
            identifier,
            url,
            token,
            baseUrl: appOptions.baseUrl,
            provider
          });
        },

        async getVerificationRequest(identifier, token) {
          const hashedToken = hashToken(token);
          const verificationRequest = await manager.findOne(VerificationRequest, {
            identifier,
            token: hashedToken
          });

          if (verificationRequest !== null && verificationRequest !== void 0 && verificationRequest.expires && new Date() > new Date(verificationRequest.expires)) {
            await manager.delete(VerificationRequest, {
              token: hashedToken
            });
            return null;
          }

          return verificationRequest;
        },

        async deleteVerificationRequest(identifier, token) {
          const hashedToken = hashToken(token);
          await manager.delete(VerificationRequest, {
            identifier,
            token: hashedToken
          });
        }

      };
    }

  };
}